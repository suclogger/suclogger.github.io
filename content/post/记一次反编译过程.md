---
title: 记一次反编译过程
comments: true
toc: true
categories:
  - 逆向
tags:
  - disassemble
date: 2016-09-25 19:43:27
---
<!-- abstract -->
<!-- 开始正文 -->

**此文不涉及任何道义和伦理的讨论**

## 尝试旧版本APP，查看对应的旧版本接口是否加密
安卓的历史版本可以通过[hiapk](http://apk.hiapk.com)下载，资源的链接一般类似这种形式： [http://apk.hiapk.com/appinfo/com.maihaoche.bentley/1050805](http://apk.hiapk.com/appinfo/com.maihaoche.bentley/1050805)，最后的数字用于标识不同的版本号。
IOS的历史版本可以通过itunes下载，只需修改请求中携带的版本号即可下载不同版本，具体参见：[iTunes下载 App Store 任意历史版本应用](http://bbs.itools.cn/thread-93616-1-1.html)。

![](/image/2016-09-25-19-55-38.jpg)
在mac上通过`Genymotion`可以安装安卓apk，在虚拟中配置代理地址`10.0.3.2`，端口8888，配合`charles`即可将虚拟机中请求拦截到`charles`中。

![](/image/2016-09-25-19-59-25.png)

![](/image/2016-09-25-20-01-47.jpg)

分析了若干历史版本之后，发现该的App2.X版本未进行加密，但是对应的域名和接口也已经停用，所以这条路走不通。

## 尝试反编译APP
apk的反编译可以使用：[apk2gold](https://github.com/lxdvs/apk2gold)
反编译之后，可以看到解析出的java代码。
得到代码之后如何定位到加密部分的逻辑因场景而定，在这个app中，定位到一个关键类**BaseWeb**，代码如下：
```
protected static TreeMap<String, Object> jiaMi(TreeMap<String, Object> treeMap, boolean z) {
        ...
        try {
            String sha1 = sha1(treeMap, z);
            if (sha1 == null) {
                return null;
            }
            treeMap2.put("key", sha1);
            return treeMap2;
        } catch (Exception e) {
            u.a(e);
            treeMap2.put("key", "");
            return treeMap2;
        }
    }
```

可以看到`key`字段是通过`sha1`函数生成，具体代码如下：

```
public static String sha1(TreeMap<String, Object> treeMap, boolean z) {
        if (treeMap == null) {
            treeMap = new TreeMap();
        }
        if (!z) {
            treeMap.put("publicKey", Info.a().getMoreStrInfo(AppContext.getInstance(), 345));
        } else if (!mApplication.isLogin()) {
            return null;
        } else {
            treeMap.put("publicKey", mApplication.getUser().getPrivateKey());
        }
        if (treeMap == null || treeMap.size() <= 0) {
            return "";
        }
        String str = "";
        int i = 0;
        for (String str2 : treeMap.keySet()) {
            Object obj = treeMap.get(str2);
            if (obj != null) {
                if (i > 0) {
                    str = str + "^_~";
                } else {
                    i++;
                }
                ...                    
                str = str + str2 + "=" + formaterFloat(Double.parseDouble(obj.toString()));
                ...
            }
        }
        // 标准的sha1加密
        return i.e(str);
    }
```

这个方法根据`z`的取值决定`publicKey`是通过` Info.a().getMoreStrInfo(AppContext.getInstance(), 345)`这个方法来生成，还是直接取`mApplication.getUser().getPrivateKey()` 。
因为我们感兴趣的接口的`z`取值都是`false`，所以要深入探究一下` Info.a().getMoreStrInfo(AppContext.getInstance(), 345)`这个方法。
反编译发现这个方法是包裹在so中，也是常见的保护敏感信息的方式。
Hopper反编译 结果：
![](/image/2016-09-26-15-01-36.png)

祭出神器`IDA Pro`，代码可读性提高很多：

![](/image/2016-09-26-01-58-38.jpg)
汇编无力，直接F5:
找到传入参数为345时候的对应逻辑：
![](/image/2016-09-26-02-00-24.png)

其实就是简单取得了一个字符串：**4cbce54e------17c70193**

## 成功
因为参数是完全明文的，将参数和反编译获取的`publicKey`放入`TreeMap`，拼接成字符串之后执行标准sha1，即可获取一个合法的`key`：

```
        TreeMap<String,Object> treeMap = new TreeMap();
        treeMap.put("publicKey", "4cbce54---------70193");
        treeMap.put("参数key", "参数value");

        String str = "";
        int i = 0;
        for (String str2 : treeMap.keySet()) {
            Object obj = treeMap.get(str2);
            if (obj != null) {
                if (i > 0) {
                    str = str + "^_~";
                } else {
                    i++;
                }
                if (obj instanceof String) {
                    str = str + str2 + "=" + obj;
                }
            }
        }
        System.out.println(e(str));
```

## 对比结果

真实请求：
![](/image/2016-09-26-14-57-11.jpg)

模拟 key ：
![](/image/2016-09-26-14-56-46.jpg)





